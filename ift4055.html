<!DOCTYPE html>
<meta charset="utf-8">

<html>
<head>
    <title>IFT4055</title>
        <link rel="stylesheet" href="assets/css/bootstrap.min.css">
</head>

<body>

    <nav class="navbar navbar-inverse">
        <div class="container">
          <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target=".navbar-collapse">
              <span class="sr-only">Toggle navigation</span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
            </button>
                      <a class="navbar-brand" href="#">antaki.vincent</a>
          </div>
          <div class="navbar-collapse collapse">
            <ul class="nav navbar-nav">
              <li><a href="index.html">Accueil</a></li>
              <li><a href="enseignement.html">Enseignement</a></li>
              <li><a href="cours.html">Cours</a></li>
              <li><a href="contact.html">Contact</a></li>
            </ul>
          </div><!--/.nav-collapse -->
        </div>
      </nav>      
    
         <center> <h1> IFT4055 - Projet Informatique Honor</h1></center>
            <div class="well sidebar-nav">
            <h3>Description du projet</h3>
            <p>Le projet consiste à développer un ou des modules d’un nouvel outil qui permet de résoudre le problème d’accessibilité pour des systèmes à compteurs (VASS, réseaux de Petri). Puisqu’il n’existe aucune borne supérieure sur le temps nécessaire afin de résoudre le problème d’accessibilité, la stratégie initiale proposée consiste à :

<li> Considérer des relaxations du problème afin de décider la non accessibilité; </li>
<li> Utiliser des heuritistiques, ainsi que les informations obtenues à l'étape précédente, afin de décider l’accessibilité;</li>
<li> Recourir à des méthodes de force brute en dernier lieu.</li>

Dans le cadre de ce projet, l'étudiant est également appelé à comprendre, démontrer ou adapter certains résultats théoriques afin d’appuyer l’implémentation des différents modules de l’outil ou potentiel module. </p>
</div>
<div class="well sidebar-nav">
            <a name="final"></a>
            <h3>Remise et compte-rendu des résultats -- [ 2 mai 2015 ]</h3>
            <p> Durant le projet ont été définis deux modèles VASS continu. L'un d'entre eux a été prouvé équivalent aux réseaux de Petri continus (CPN) et l'autre est à priori une nouvelle relaxation. Une implémentation en Python de l'algorithme de Fracca et Haddad pour résoudre le problème d'accessibilité dans les CPN à été développé à l'aide de <a href="http://www.math.uwaterloo.ca/~bico/qsopt/ex/">QSopt_ex</a> et <a href="http://www.numpy.org/">Numpy</a>. 

            <li> <a href="antaki-02-05-2015.pdf">Accessibilité dans les systèmes à compteurs continues: théorie et pratique</a>, le rapport de projet.</li>
            <!--<li><a href="cpn_access.tar.gz">cpn_access</a>, le module développé.</li>-->
            <li>La <a href="presentation.pdf">présentation</a> du projet.</li>
            
            </p>
        
        
            </div>   
    <div class="col-fluid">
        <div class="col-md-3">
          
          <div class="well sidebar-nav">
              <h4>Superviseur : </h4>
              <a href="http://www.iro.umontreal.ca/~mckenzie/">Pierre Mckenzie</a>           
          </div>
          
          <div class="well sidebar-nav">
            <ul class="nav nav-list">
              <li class="nav-header"><h4>Index</h4></li>
              <li><a href="#semaine0">Semaine 0</a></li>
              <li><a href="#semaine1">Semaine 1</a></li>
              <li><a href="#semaine2">Semaine 2</a></li>
              <li><a href="#semaine3">Semaine 3</a></li>
              <li><a href="#semaine4">Semaine 4</a></li>
              <li><a href="#semaine5">Semaine 5</a></li>
              <li><a href="#semaine6">Semaine 6</a></li>
              <li><a href="#semaine7">Semaine 7</a></li>
              <li><a href="#semaine8">Semaine 8</a></li> 
              <li><a href="#semaine9">Semaine 9</a></li>            
              <li><a href="#semaine10">Semaine 10</a></li> 
              <li><a href="#semaine11">Semaine 11</a></li>                    
              <li><a href="#semaine12">Semaine 12</a></li>                    
              <li><a href="#semaine13">Semaine 13</a></li> 
              <li><a href="#semaine14">Semaine 14</a></li>               
              <li><a href="#semaine15">Semaine 15</a></li> 
              <li><a href="#semaine16">Semaine 16</a></li>                       
              </ul>
          </div><!--/.well -->
          
          
        </div><!--/span-->
     
        <div class="col-md-9" id=>
            <h3>Compte-rendus hebdomadaires</h3>
            <a name="semaine16"></a>
            <h4>Semaine 16 -- [ 22 avril, 29 avril ]</h4>
            <p> J'ai remis ce vendredi une version avec les corrections apportées. Suite au feedback de Michael sur la version corrigée, j'ai remis une nouvelle version ce mercredi. </p>
        
            <a name="semaine15"></a>
            <h4>Semaine 15 -- [ 15 avril, 22 avril ]</h4>
            <p>Écriture du rapport. J'ai remis ce vendredi une version avec les sections 1 à 3 prêtes à être révisées. J'ai remis lundi les sections 4 et 5 prêtes à être révisées. </p>

        
            <a name="semaine14"></a>
            <h4>Semaine 14 -- [ 8 avril, 15 avril ]</h4>
            <p>Écriture du rapport. Un peu moins que les 10 heures supposées ont été mise dans le projet cette semaine. Je n'ai aucun doute sur le fait que la semaine prochaine compensera la balance au niveau des heures. Pas de rencontre ce mercredi (15 avril).</p>

        
            <a name="semaine13"></a>
            <h4>Semaine 13 -- [ 1 avril, 8 avril ]</h4>
            <p>Écriture du rapport. Durant la réunion aujourd'hui (8 avril), on est repassé surtout sur le début des 3 premières sections du rapport et beaucoups de modifications sont à apporter.</p>
        
        
            <a name="semaine12"></a>
            <h4>Semaine 12 -- [ 25 mars, 1 avril ]</h4>
            <p>Écriture du rapport.</p>
        
        
            <a name="semaine11"></a>
            <h4>Semaine 11 -- [ 18 mars, 25 mars ]</h4>
            <p>Le code est totalement fonctionnel et tous les tests passent. Par contre, je n'ai pas pu avancer l'écriture du rapport. Je clanche ça la semaine prochaine.</p>
        
            <a name="semaine10"></a>
            <h4>Semaine 10 -- [ 11 mars, 18 mars ]</h4>
            <p> J'ai trouvé un solver rationnel qui me semble vraiment approprié qui se nomme QSopt_ex. QSopt_ex est un simplexe exact écrit en C. Ce dernier commence à résoudre le problème avec des floats-64 et test la réponse symboliquement. Si celle-ci n'est pas valide, il augmente la précision et réutilise sa dernière solution comme base de la phase II du simplexe. Après une certaine précision critique, celui-ci prends la dernière base valide et la met dans un solver rationnel. J'utilise avec quelques modifications un binding en Cython trouvé sur Github de cette librairie. Le solver marche bien. Il me reste encore un peu de débug et d'embellissement de code à faire. Une caractéristique du solver est qu'il ne me permet pas de récupérer une solution valide lorsque le problème est non-borné (l'objectif est de maximiser la variable avec la contrainte de positivité stricte - voir <a href="#semaine2">Semaine 2</a>). Pour l'instant, je contourne le problème en faisant deux autres simplexes avec (l'un qui tente de maximiser la dite variable mais qui la borne supérieurement à un et l'autre qui tente de minimiser et qui la borne inférieurement à un) mais je me questionne à savoir s'il y aurait une manière plus optimale de le faire. </p>
            
            <p>Pour ce qui est du précédents solver et de l'heuristique à aller chercher, je n'ai pas trouvé d'algo qui approxime le rationnel représenté par le float avec du pattern matching. Mon plan est le suivant : Convertir en rationnel le float en le supposant exact et utiliser une borne arbitraire sur le dénominateur du rationnel représenté, puis de tester symboliquement le résultat. En cas d'échec, je passerais au solver rationnel. </p>
            
            <p>Si tout continue comme il faut, je devrais avoir une version de base prête pour la remise la semaine prochaine. Après, ce sera écriture du rapport et peut-être benchmarking.</p>        
            
            <a name="semaine9"></a>
            <h4>Semaine 9 -- [ 4 mars, 11 mars ]</h4>
            <p>J'ai continuer un peu à rédiger le document sur les CVASMS mais j'ai surtout fait du débug en continuant le développement de la procédure de vérification. Il y a un problème avec le fait que le solver est en float64 qui entraine l'échec du test de vérification dans certains cas (dans les cas où le chiffre est approximé par la représentation float). Il faut que je creuse un peu là-dessus pour voir s'il y a une heuristique pour approximer le chiffre rationnel que peut représenter un float mais je pense que d'utiliser un solver rationnel se pose comme meilleure alternative. 
                        </p>        

            <a name="semaine8"></a>
            <h4>Semaine 8 -- [ 25 février, 4 mars ]</h4>
            <p>J'ai entamé la programmation d'une procédure de vérification du résultat retourné par scipy.optimize.linprog. Celle-ci contient une application du Lemme de Farkas.</p>
            
            <p>Après avoir longtemps cherché la cause du bug dans limReachTest (celui trouvé à la fin de la semaine 5), j'ai des raisons de croire qu'il s'agit d'une erreur dans linprog car l'erreur survient sur un input particulier contenant une fonction callback indépendamment de ce que la fonction callback est. J'ai déposé un issue sur le dépôt github de scipy.</p> 

            <p>J'ai commencé a taper sur LaTeX les définitions, preuves et procédures associées des CVASMS.</p>

            <a name="semaine7"></a>
            <h4>Semaine 7 -- [ 18 février, 25 février ]</h4>
            <p>J'ai défini les propriétés des CVASMS et ainsi que pour les CVASUS. Je travaille sous l'hypothèse que les problèmes pouvant être représenté dans un CPN le sont aussi dans un CVASMS et vice-versa. Dans cet esprit, j'ai écrit des procédures de conversition d'un CVASMS vers un CPN, d'un CPN vers un CVASMS et d'une éxécution de CPN vers une exécution de CVASMS. J'ai entamé l'écriture de la procédures pour la transformation d'une exécution CVASMS->CPN ainsi que la preuve de l'équivalence de son résultat avec l'input. La version au propre de tout ça n'est pas encore entamée. </p>        
        
            <a name="semaine6"></a>
            <h4>Semaine 6 -- [ 11 février, 18 février ]</h4>
            <p>Très peu d'heures à mettre cette semaine à cause de la mi-session. Je reprendrai les heures manquées sur les 2 prochaines semaines.</p>
            
            
            <a name="semaine5"></a>
            <h4>Semaine 5 -- [ 4 février, 11 février ]</h4>
            <p> Lecture légère de l'article On Reachability of Continuous Petri Net Systems par Júlvez, Recalde et Silva [JRS03] avec comme perspective de l'adapter aux VASS continus (CVASS). La logique derrière la preuve de décidabilité est similaire à celle de la preuve dans [FH13]. Certains problèmes arrivent lorsqu'on souhaite appliquer une logique similaire aux VASS :
            <li> Il n'est pas possible de tenir la même analyse basée sur la "firing sequence" à partir d'un marquage initial car il y a une ordre dans les transitions à appliquer. Toutefois, il est possible d'identifier un facteur contraignant dans une liste de transitions à appliquer séquenciellement </li>
            <li> Les siphons et les traps dans les réseaux de pétri n'ont pas d'équivalence dans les VASS.</li>            
            </p>
            
            <p>La question majeure avant d'aller plus loin est la suivante : Comment défini-t-on les CVASS? Deux options se présentent et elles se distinguent au niveau de ce qui se passe avec l'état lorsqu'une fraction &#945 d'une transition est activée :
                <li> Avoir une fraction &#945 de la transition qui passe au prochain état. Il serait donc possible d'être dans plusieurs états à la fois et donc, éventuellement, d'activer des transitions qui ne sont pas consécutive dans le graphe. Nommons pour l'instant ce modèle CVASS avec états multiples (CVASMS). Je pense qu'il est possible de prouver l'équivalence de ce modèle avec les réseaux de Pétri continus (CPN).</li>  
                <li> Avoir l'entièreté de l'état qui est changé lorsqu'une fraction de transition est activée. Il serait donc possible de passer à un état subséquent en activant une transition avec un coefficient positif qui tend vers 0 et ce en changeant la configuration/marquage de manière infiniment petite. Il y aurait des cas où les comportements de ce modèle sont un peu étrange. Par exemple, dans un cycle négatif qui contient un arc positif, il serait possible d'augmenter à l'infini les valeurs dans la configuration. Nommons pour l'instant ce modèle CVASS avec état unique (CVASUS)</li> </p>  
                
            <p>Sinon, j'ai rajouté un test sur Reachable et découvert deux bugs... il y en a un de réglé et je vais bosser sur l'autre.</p>
   

            <a name="semaine4"></a>
            <h4>Semaine 4 -- [ 28 janvier, 4 février ]</h4>
            <p>Fireable et reachable fonctionnent. La partie de la preuve du lemme 12 qui était encore un peu nébuleuse à été comprise. </p>  
   
        
            <a name="semaine3"></a>
            <h4>Semaine 3 -- [ 21 janvier, 28 janvier ]</h4>
            <p>J'ai changé la représentation des réseaux de Petri, ceux-ci sont maintenant représentés par une matrice de tuples (le premier élément correspondant au Pre[p,t], le deuxième à Post[p,t]) du type structured array de numpy. La convertion des algos et des opérations sur cette structure est faite (et n'a pas pris très longtemps). Les tests ont aussi été adaptés à cette structure. Fireable est fonctionnel et testé. Il me reste encore un tout petit peu de débogage sur reachable (scipy.optimize.linprog ne me retourne plus le "appears to be unfeasable", yay!).</p>  
            
            <p>J'ai lu l'article [FH13] plus en profondeur. La preuve du lemme 12 et la proposition 17 sont assez corsés et j'ai encore certains problèmes à les comprendre. </p>
               
            <p>J'ai été chercher une copie de la librairie CPLEX d'IBM au CIRRELT. Éventuellement, j'essayerai peut-être de remplacer optimize.linprog par CPLEX et de comparer leur efficacité mais ça ne m'apparait vraiment pas prioritaire. </p>
                
            
            <p> Suite à la rencontre du 28 janvier avec Pierre et Michael, le lemme 12 m'apparait déjà plus clair. Voici mes objectifs pour la semaine prochaine :
            
              <li>Expliciter la preuve du lemme 12 de [FH13]</li>
              <li>Avoir Fireable et Reachable complété et testé.</li>
              <li>Prendre connaissance des limites de scipy.optimize.linprog (approximation des résultats lorsque la solution est dans les rationnels?) et concevoir un test pour confirmer le résultat (faisabilité/non-faisabilité du problème) retourné par le solver.</li>
            </p>    
            
            <p>--- Retour sur la semaine 2 ---</p>
            <p>La semaine dernière j'ai affirmé que les systèmes linéaires contenant des contraintes d'inégalités strictes semblait constituer un problème NP-Complet. C'est faux. Il existe divers algorithmes, l'algorithme de l'ellipsoïde entre autre, qui peuvent résoudre le problème en temps polynomial.</p> 
            
        
            <a name="semaine2"></a>
            <h4>Semaine 2 -- [ 14 janvier, 21 janvier ]</h4>
            <p> L'algorithme reachable de [FH13] est complété, à l'exception du solver. Il semblerait que les algorithmes résolvant les systèmes linéaires contenant des contraintes d'inégalités strictes ne pleuvent pas (le problème semble être NP-Complet). La seule contrainte d'inégalité stricte dans le système est v[t] > 0 (où v est le vecteur solution du système) et c'est celle-ci qui complique la tâche de trouver un solver.</p>
            
<p>La fonction linprog du module optimize de scipy semble plutôt appropriée (voir prochain paragraphe). Elle implémente la technique du simplexe, pouvant résoudre des systèmes linéaires de contraintes d'égalités et d'<b>inégalités non-stricte</b>. Composé de 2 phases: 1 - Trouver une solution valide; 2 - Minimiser en suivant une fonction objective. Il est possible de passer en paramètre une fonction callback qui est appelée après chaque itération et qui recoit en paramètre la configuration du simplexe. </p>

                   <p>L'idée est de passer à scipy.optimize.linprog le système de contraintes en excluant la contrainte v[t] > 0 et de définir la fonction objectif (minimisation) avec un coefficient négatif pour v[t] et un coefficient nul pour les autres éléments de v. Ainsi, le simplexe, à la phase 2, tentera de maximiser v[t]. Puisque nous n'avons besoin que d'une solution valide, linprog reçoit une fonction en paramètre callback qui lève une exception StopIteration si le simplexe est dans sa deuxième phase (et itère donc sur des solutions valides) et que v[t] > 0. Ainsi, il nous serait possible d'essayer de résoudre un système ne contenant pas d'inégalité stricte et d'arrêter l'optimisation lorsque la contrainte d'inégalité stricte est respectée.</p>
                   
                   <p> J'ai développé un test de cas particulier pour reachable et il échout. Il semblerait que optimize.linprog n'est pas capable de terminer sa phase I et que le système de contraintes "appears to be unfeasable". C'est plutôt étrange vue la simplicité du cas donné en entrée et que je suis capable de trouver une solution valide à la main. Séance de débogage en perspective. </p>
                   
                   <p>Le pire cas du simplexe n'est pas en temps polynomial mais reachable est supposé être faisable en PTIME. L'article de Fraca et Haddad donne en référence le livre Combinatorial Optimization de C. H. Papadimitriou et K. Steigliz  comme preuve que le système d'inégalités se résoud en temps polynomial. J'ai été le chercher à la bibliothèque. Celui-ci semble dire que le meilleur algorithme possible est en temps polynomial mais très peu avantageux dans les instances de petite taille.</p>

            <p>Les tests sont développés avec unittest (inclus dans python) et nose. Scipy et Nose ont été rajoutés dans les dépendances pour le projet. J'envisage de rajouter Contracts dans les dépendances pour faire des contraintes de type OCL de manière plus élégante que des assertions au début et à la fin des fonctions.</p>

<!--
 -->
            <a name="semaine1"></a>
            <h4>Semaine 1 -- [ 8 janvier, 14 janvier ]</h4>
            <p>Le site web est fait. J'ai lu en diagnonale l'article de Complexity Analysis of Continous Petri Net de Fraca et Haddad [<a href="http://www.lsv.ens-cachan.fr/Publis/PAPERS/PDF/rr-lsv-2013-01.pdf">FH13</a>]. La structure des réseaux de Petri ainsi que les fonctions qui permettent de les manipuler sont faites. Les tests associés sont bien entamés. J'ai terminé de coder l'algorithme 1 de [FH13] (fireable) mais pas encore testé et j'ai entamé l'algo 2 de [FH13] (reachable) de CPN-analysis. Lecture d'une partie de la documentation de numpy et recherche d'un  solveur pour le système linéaire dans l'algorithme reachable. J'ai envoyé une demande à GitHub pour avoir accès gratuitement à des dépôts privés dans le cadre de leur "Github Student Developer Pack". Pour l'instant, le projet est sur un dépôt privé de mon bon ami Guillaume Poirier-Morency.</p>
            
            <a name="semaine0"></a>
            <h4>Semaine 0 -- ] - &#8734, 8 janvier]</h4>
            <p>Lecture du rapport prédoctoral de <a href="http://www-etud.iro.umontreal.ca/~blondimi">Michael Blondin</a>, Algorithmique et complexité des systèmes à compteur.</p>
            
        </div>
        Avis aux lecteurs : Les semaines commencent et terminent un mercredi, date fatidique de réunion.
     </div>

</body>
